<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Фазовый портрет — Линейные ДУ</title>
    
    <!-- Plotly.js для визуализации -->
    <script src="https://cdn.plot.ly/plotly-2.26.0.min.js"></script>
    
    <!-- Шрифты -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600&family=Source+Sans+3:wght@400;500;600&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --bg-primary: #0f0f12;
            --bg-secondary: #18181c;
            --bg-elevated: #1f1f24;
            --bg-hover: #27272d;
            --border: #2e2e36;
            --text-primary: #e8e8ed;
            --text-secondary: #9898a4;
            --text-muted: #5c5c68;
            --accent: #4f8cff;
            --accent-hover: #6ba0ff;
            --accent-muted: rgba(79, 140, 255, 0.15);
            --danger: #ff5f5f;
            --success: #4ade80;
            --warning: #fbbf24;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Source Sans 3', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            line-height: 1.5;
        }
        
        .app {
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }
        
        /* Header */
        .header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 24px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border);
        }
        
        .header-title {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .logo {
            width: 32px;
            height: 32px;
            background: var(--accent);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .logo svg {
            width: 18px;
            height: 18px;
            fill: white;
        }
        
        .header h1 {
            font-size: 16px;
            font-weight: 600;
            letter-spacing: -0.01em;
        }
        
        .header-subtitle {
            font-size: 13px;
            color: var(--text-secondary);
        }
        
        /* Main Layout */
        .main {
            display: flex;
            flex: 1;
            overflow: hidden;
        }
        
        /* Sidebar */
        .sidebar {
            width: 280px;
            background: var(--bg-secondary);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }
        
        .sidebar-section {
            padding: 16px;
            border-bottom: 1px solid var(--border);
        }
        
        .sidebar-section:last-child {
            border-bottom: none;
        }
        
        .section-title {
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-muted);
            margin-bottom: 12px;
        }
        
        /* Select */
        select {
            width: 100%;
            padding: 8px 12px;
            background: var(--bg-elevated);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text-primary);
            font-size: 13px;
            font-family: inherit;
            cursor: pointer;
            transition: border-color 0.15s;
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24' fill='none' stroke='%239898a4' stroke-width='2'%3E%3Cpath d='M6 9l6 6 6-6'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 10px center;
        }
        
        select:hover {
            border-color: var(--text-muted);
        }
        
        select:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 3px var(--accent-muted);
        }
        
        /* Button */
        button {
            width: 100%;
            padding: 8px 12px;
            background: var(--bg-elevated);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text-primary);
            font-size: 13px;
            font-family: inherit;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.15s;
            margin-top: 10px;
        }
        
        button:hover {
            background: var(--bg-hover);
            border-color: var(--text-muted);
        }
        
        button.primary {
            background: var(--accent);
            border-color: var(--accent);
            color: white;
        }
        
        button.primary:hover {
            background: var(--accent-hover);
            border-color: var(--accent-hover);
        }
        
        button.animation-active {
            background: var(--danger);
            border-color: var(--danger);
            color: white;
        }
        
        button.animation-active:hover {
            opacity: 0.9;
        }
        
        /* Sliders */
        .slider-row {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 12px;
        }
        
        .slider-row:last-child {
            margin-bottom: 0;
        }
        
        .slider-label {
            font-size: 13px;
            font-family: 'JetBrains Mono', monospace;
            color: var(--text-secondary);
            width: 16px;
            flex-shrink: 0;
        }
        
        .slider-track {
            flex: 1;
            position: relative;
        }
        
        input[type="range"] {
            width: 100%;
            height: 4px;
            border-radius: 2px;
            background: var(--bg-hover);
            outline: none;
            -webkit-appearance: none;
            cursor: pointer;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: var(--accent);
            cursor: pointer;
            transition: transform 0.1s;
        }
        
        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.15);
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: var(--accent);
            cursor: pointer;
            border: none;
        }
        
        .slider-value {
            font-size: 12px;
            font-family: 'JetBrains Mono', monospace;
            color: var(--accent);
            width: 48px;
            text-align: right;
            flex-shrink: 0;
        }
        
        /* Math Info */
        .math-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }
        
        .math-item {
            background: var(--bg-elevated);
            padding: 8px 10px;
            border-radius: 6px;
            border: 1px solid var(--border);
        }
        
        .math-item.full {
            grid-column: 1 / -1;
        }
        
        .math-label {
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.04em;
            color: var(--text-muted);
            margin-bottom: 2px;
        }
        
        .math-value {
            font-size: 13px;
            font-family: 'JetBrains Mono', monospace;
            color: var(--text-primary);
        }
        
        .math-type {
            font-size: 13px;
            font-weight: 600;
            color: var(--accent);
        }
        
        /* Graph Area */
        .graph-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 16px;
            min-width: 0;
        }
        
        #phasePortrait {
            flex: 1;
            min-height: 400px;
            border-radius: 8px;
            overflow: hidden;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
        }
        
        /* Right Panel */
        .right-panel {
            width: 180px;
            background: var(--bg-secondary);
            border-left: 1px solid var(--border);
            padding: 16px;
        }
        
        /* Responsive */
        @media (max-width: 1000px) {
            .main {
                flex-direction: column;
            }
            
            .sidebar, .right-panel {
                width: 100%;
                max-height: 200px;
                border: none;
                border-bottom: 1px solid var(--border);
            }
            
            .right-panel {
                border-top: 1px solid var(--border);
                border-bottom: none;
            }
        }
    </style>
</head>
<body>
    <div class="app">
        <header class="header">
            <div class="header-title">
                <div class="logo">
                    <svg viewBox="0 0 24 24"><path d="M3 3v18h18V3H3zm16 16H5V5h14v14zM7 7h2v2H7V7zm4 0h2v2h-2V7zm4 0h2v2h-2V7zm-8 4h2v2H7v-2zm4 0h2v2h-2v-2zm4 0h2v2h-2v-2zm-8 4h2v2H7v-2zm4 0h2v2h-2v-2zm4 0h2v2h-2v-2z"/></svg>
                </div>
                <div>
                    <h1>Фазовый портрет</h1>
                    <div class="header-subtitle">Системы линейных дифференциальных уравнений</div>
                </div>
            </div>
        </header>
        
        <main class="main">
            <aside class="sidebar">
                <div class="sidebar-section">
                    <div class="section-title">Пресеты</div>
                    <select id="presetSelect">
                        <option value="custom">Произвольная матрица</option>
                        <option value="stable_node">Устойчивый узел</option>
                        <option value="unstable_node">Неустойчивый узел</option>
                        <option value="saddle">Седло</option>
                        <option value="stable_focus">Устойчивый фокус</option>
                        <option value="unstable_focus">Неустойчивый фокус</option>
                        <option value="center">Центр</option>
                    </select>
                    <button id="animateBtn" class="primary">Запустить анимацию</button>
                </div>
                
                <div class="sidebar-section">
                    <div class="section-title">Матрица A</div>
                    
                    <div class="slider-row">
                        <span class="slider-label">a</span>
                        <div class="slider-track">
                            <input type="range" id="sliderA" min="-10" max="10" step="0.1" value="-1">
                        </div>
                        <span class="slider-value" id="valueA">-1.00</span>
                    </div>
                    
                    <div class="slider-row">
                        <span class="slider-label">b</span>
                        <div class="slider-track">
                            <input type="range" id="sliderB" min="-10" max="10" step="0.1" value="-2">
                        </div>
                        <span class="slider-value" id="valueB">-2.00</span>
                    </div>
                    
                    <div class="slider-row">
                        <span class="slider-label">c</span>
                        <div class="slider-track">
                            <input type="range" id="sliderC" min="-10" max="10" step="0.1" value="2">
                        </div>
                        <span class="slider-value" id="valueC">2.00</span>
                    </div>
                    
                    <div class="slider-row">
                        <span class="slider-label">d</span>
                        <div class="slider-track">
                            <input type="range" id="sliderD" min="-10" max="10" step="0.1" value="-1">
                        </div>
                        <span class="slider-value" id="valueD">-1.00</span>
                    </div>
                    
                    <button id="normalizeBtn">Нормализовать</button>
                </div>
                
                <div class="sidebar-section">
                    <div class="section-title">Характеристики</div>
                    <div class="math-grid">
                        <div class="math-item">
                            <div class="math-label">След (tr)</div>
                            <div class="math-value" id="mathTr">—</div>
                        </div>
                        <div class="math-item">
                            <div class="math-label">Опред. (det)</div>
                            <div class="math-value" id="mathDet">—</div>
                        </div>
                        <div class="math-item">
                            <div class="math-label">λ₁</div>
                            <div class="math-value" id="mathLambda1">—</div>
                        </div>
                        <div class="math-item">
                            <div class="math-label">λ₂</div>
                            <div class="math-value" id="mathLambda2">—</div>
                        </div>
                        <div class="math-item full">
                            <div class="math-label">Тип особой точки</div>
                            <div class="math-type" id="mathType">—</div>
                        </div>
                    </div>
                </div>
            </aside>
            
            <div class="graph-area">
                <div id="phasePortrait"></div>
            </div>
            
            <aside class="right-panel">
                <div class="section-title">Визуализация</div>
                
                <div class="slider-row" style="margin-bottom: 16px; margin-top: 8px;">
                    <span class="slider-label" style="width: auto; margin-right: 8px;">Границы</span>
                    <span class="slider-value" id="valueLimit">5.0</span>
                </div>
                <input type="range" id="sliderLimit" min="2" max="10" step="0.5" value="5" style="margin-bottom: 20px;">
                
                <div class="slider-row" style="margin-bottom: 16px;">
                    <span class="slider-label" style="width: auto; margin-right: 8px;">Плотность</span>
                    <span class="slider-value" id="valueDensity">1.0</span>
                </div>
                <input type="range" id="sliderDensity" min="0.5" max="2.0" step="0.1" value="1.0">
                
                <div style="margin-top: 24px; padding-top: 16px; border-top: 1px solid var(--border);">
                    <div class="section-title">Интерактивная теория</div>
                    <a href="https://colab.research.google.com/drive/184xk_5ze3X3RlltIbXy-7hLuhOgb5HUd?usp=sharing" 
                       target="_blank" 
                       style="display: flex; align-items: center; gap: 8px; padding: 10px 12px; background: var(--bg-elevated); border: 1px solid var(--border); border-radius: 6px; color: var(--accent); text-decoration: none; font-size: 13px; transition: all 0.15s;">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-1 17.93c-3.95-.49-7-3.85-7-7.93 0-.62.08-1.21.21-1.79L9 15v1c0 1.1.9 2 2 2v1.93zm6.9-2.54c-.26-.81-1-1.39-1.9-1.39h-1v-3c0-.55-.45-1-1-1H8v-2h2c.55 0 1-.45 1-1V7h2c1.1 0 2-.9 2-2v-.41c2.93 1.19 5 4.06 5 7.41 0 2.08-.8 3.97-2.1 5.39z"/>
                        </svg>
                        Открыть в Colab
                    </a>
                    <p style="margin-top: 8px; font-size: 11px; color: var(--text-muted);">
                        Подробный разбор теории с примерами
                    </p>
                </div>
            </aside>
        </main>
    </div>
    
    <script>
        // ==========================================
        // ГЛОБАЛЬНЫЕ ПЕРЕМЕННЫЕ
        // ==========================================
        
        let currentMatrix = { a: -1, b: -2, c: 2, d: -1 };
        let currentLimit = 5;
        let currentDensity = 1.0;
        let isUpdating = false;
        
        // Анимация
        let isAnimating = false;
        let animationId = null;
        
        // Предустановленные примеры
        const presets = {
            stable_node: { a: -2, b: 0, c: 0, d: -3 },
            unstable_node: { a: 2, b: 0, c: 0, d: 3 },
            saddle: { a: 2, b: 0, c: 0, d: -2 },
            stable_focus: { a: -1, b: -2, c: 2, d: -1 },
            unstable_focus: { a: 1, b: -2, c: 2, d: 1 },
            center: { a: 0, b: -1, c: 1, d: 0 }
        };
        
        // ==========================================
        // ИНИЦИАЛИЗАЦИЯ
        // ==========================================
        
        document.addEventListener('DOMContentLoaded', function() {
            initializeControls();
            updateVisualization();
        });
        
        function initializeControls() {
            // Слайдеры матрицы
            ['A', 'B', 'C', 'D'].forEach(letter => {
                const slider = document.getElementById('slider' + letter);
                slider.addEventListener('input', function(e) {
                    if (isAnimating) stopAnimation();
                    
                    currentMatrix[letter.toLowerCase()] = parseFloat(e.target.value);
                    document.getElementById('value' + letter).textContent = parseFloat(e.target.value).toFixed(2);
                    document.getElementById('presetSelect').value = 'custom';
                    requestUpdate();
                });
            });
            
            // Слайдеры визуализации
            document.getElementById('sliderLimit').addEventListener('input', function(e) {
                currentLimit = parseFloat(e.target.value);
                document.getElementById('valueLimit').textContent = currentLimit.toFixed(1);
                requestUpdate();
            });
            
            document.getElementById('sliderDensity').addEventListener('input', function(e) {
                currentDensity = parseFloat(e.target.value);
                document.getElementById('valueDensity').textContent = currentDensity.toFixed(1);
                requestUpdate();
            });
            
            // Выбор предустановок
            document.getElementById('presetSelect').addEventListener('change', function(e) {
                if (isAnimating) stopAnimation();
                
                if (e.target.value !== 'custom') {
                    const preset = presets[e.target.value];
                    currentMatrix = { ...preset };
                    updateSliders();
                    requestUpdate();
                }
            });
            
            // Кнопка нормализации
            document.getElementById('normalizeBtn').addEventListener('click', function() {
                normalizeMatrix();
                updateSliders();
                requestUpdate();
            });
            
            // Кнопка анимации
            document.getElementById('animateBtn').addEventListener('click', function() {
                toggleAnimation();
            });
        }
        
        // ==========================================
        // АНИМАЦИЯ
        // ==========================================
        
        const animationSequence = [
            { preset: 'stable_node', name: 'Устойчивый узел' },
            { preset: 'saddle', name: 'Седло' },
            { preset: 'unstable_node', name: 'Неустойчивый узел' },
            { preset: 'unstable_focus', name: 'Неустойчивый фокус' },
            { preset: 'center', name: 'Центр' },
            { preset: 'stable_focus', name: 'Устойчивый фокус' }
        ];
        
        let currentAnimationIndex = 0;
        let animationProgress = 0;
        const transitionDuration = 2000;
        let lastAnimationTime = 0;
        
        function stopAnimation() {
            const btn = document.getElementById('animateBtn');
            isAnimating = false;
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
            btn.textContent = 'Запустить анимацию';
            btn.classList.remove('animation-active');
            btn.classList.add('primary');
        }
        
        function toggleAnimation() {
            const btn = document.getElementById('animateBtn');
            
            if (isAnimating) {
                stopAnimation();
            } else {
                isAnimating = true;
                btn.textContent = 'Остановить';
                btn.classList.remove('primary');
                btn.classList.add('animation-active');
                
                currentAnimationIndex = 0;
                animationProgress = 0;
                lastAnimationTime = performance.now();
                
                animationId = requestAnimationFrame(animateStep);
            }
        }
        
        function animateStep(timestamp) {
            if (!isAnimating) return;
            
            const deltaTime = timestamp - lastAnimationTime;
            lastAnimationTime = timestamp;
            
            animationProgress += deltaTime / transitionDuration;
            
            if (animationProgress >= 1) {
                animationProgress = 0;
                currentAnimationIndex = (currentAnimationIndex + 1) % animationSequence.length;
            }
            
            const currentPreset = presets[animationSequence[currentAnimationIndex].preset];
            const nextIndex = (currentAnimationIndex + 1) % animationSequence.length;
            const nextPreset = presets[animationSequence[nextIndex].preset];
            
            const t = easeInOutCubic(animationProgress);
            
            currentMatrix.a = lerp(currentPreset.a, nextPreset.a, t);
            currentMatrix.b = lerp(currentPreset.b, nextPreset.b, t);
            currentMatrix.c = lerp(currentPreset.c, nextPreset.c, t);
            currentMatrix.d = lerp(currentPreset.d, nextPreset.d, t);
            
            updateSliders();
            updateVisualization();
            
            if (animationProgress < 0.1) {
                document.getElementById('presetSelect').value = animationSequence[currentAnimationIndex].preset;
            }
            
            animationId = requestAnimationFrame(animateStep);
        }
        
        function lerp(a, b, t) {
            return a + (b - a) * t;
        }
        
        function easeInOutCubic(t) {
            return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
        }
        
        function requestUpdate() {
            if (!isUpdating) {
                isUpdating = true;
                requestAnimationFrame(() => {
                    updateVisualization();
                    isUpdating = false;
                });
            }
        }
        
        function updateSliders() {
            ['A', 'B', 'C', 'D'].forEach(letter => {
                const val = currentMatrix[letter.toLowerCase()];
                document.getElementById('slider' + letter).value = val;
                document.getElementById('value' + letter).textContent = val.toFixed(2);
            });
        }
        
        // ==========================================
        // МАТЕМАТИЧЕСКИЕ ВЫЧИСЛЕНИЯ
        // ==========================================
        
        function calculateCharacteristics(a, b, c, d) {
            const tr = a + d;
            const det = a * d - b * c;
            const delta = tr * tr - 4 * det;
            
            let lambda1, lambda2, isComplex, pointType;
            
            if (delta >= 0) {
                const sqrtDelta = Math.sqrt(delta);
                lambda1 = (tr + sqrtDelta) / 2;
                lambda2 = (tr - sqrtDelta) / 2;
                isComplex = false;
                
                if (det < 0) {
                    pointType = "Седло";
                } else if (Math.abs(lambda1 - lambda2) < 1e-10) {
                    pointType = Math.abs(b) < 1e-10 && Math.abs(c) < 1e-10 ? "Дикритический узел" : "Вырожденный узел";
                } else {
                    if (lambda1 < 0 && lambda2 < 0) pointType = "Устойчивый узел";
                    else if (lambda1 > 0 && lambda2 > 0) pointType = "Неустойчивый узел";
                    else pointType = "Седло";
                }
            } else {
                const realPart = tr / 2;
                const imagPart = Math.sqrt(Math.abs(delta)) / 2;
                lambda1 = { real: realPart, imag: imagPart };
                lambda2 = { real: realPart, imag: -imagPart };
                isComplex = true;
                
                if (realPart < -1e-10) pointType = "Устойчивый фокус";
                else if (realPart > 1e-10) pointType = "Неустойчивый фокус";
                else pointType = "Центр";
            }
            
            return { tr, det, delta, lambda1, lambda2, isComplex, pointType };
        }
        
        function normalizeMatrix() {
            const { a, b, c, d } = currentMatrix;
            const norm = Math.sqrt(a*a + b*b + c*c + d*d);
            if (norm > 10) {
                const scale = 10.0 / norm;
                currentMatrix.a *= scale;
                currentMatrix.b *= scale;
                currentMatrix.c *= scale;
                currentMatrix.d *= scale;
            }
        }
        
        // ==========================================
        // ВИЗУАЛИЗАЦИЯ
        // ==========================================
        
        function updateVisualization() {
            const { a, b, c, d } = currentMatrix;
            const math = calculateCharacteristics(a, b, c, d);
            
            updateMathInfo(math);
            
            const plotData = createPlotData(a, b, c, d, math);
            
            const graphContainer = document.getElementById('phasePortrait');
            const layout = {
                title: {
                    text: math.pointType,
                    font: { 
                        size: 16, 
                        color: '#e8e8ed',
                        family: 'Source Sans 3, sans-serif'
                    },
                    y: 0.98
                },
                xaxis: {
                    title: { text: 'x', font: { size: 13, color: '#9898a4' } },
                    range: [-currentLimit, currentLimit],
                    showgrid: true,
                    gridcolor: '#2e2e36',
                    gridwidth: 1,
                    zeroline: true,
                    zerolinecolor: '#5c5c68',
                    zerolinewidth: 1,
                    tickfont: { color: '#9898a4', size: 11 },
                    fixedrange: true
                },
                yaxis: {
                    title: { text: 'y', font: { size: 13, color: '#9898a4' } },
                    range: [-currentLimit, currentLimit],
                    showgrid: true,
                    gridcolor: '#2e2e36',
                    gridwidth: 1,
                    zeroline: true,
                    zerolinecolor: '#5c5c68',
                    zerolinewidth: 1,
                    tickfont: { color: '#9898a4', size: 11 },
                    scaleanchor: 'x',
                    scaleratio: 1,
                    fixedrange: true
                },
                width: graphContainer.offsetWidth || 700,
                height: graphContainer.offsetHeight || 600,
                margin: { l: 50, r: 30, t: 50, b: 50 },
                plot_bgcolor: '#18181c',
                paper_bgcolor: '#18181c',
                showlegend: true,
                legend: {
                    x: 1,
                    y: 1,
                    xanchor: 'right',
                    yanchor: 'top',
                    bgcolor: 'rgba(24, 24, 28, 0.9)',
                    bordercolor: '#2e2e36',
                    borderwidth: 1,
                    font: { color: '#e8e8ed', size: 11 }
                },
                hovermode: false
            };
            
            Plotly.react('phasePortrait', plotData, layout, {
                staticPlot: true,
                displayModeBar: false,
                responsive: true
            });
        }
        
        function createPlotData(a, b, c, d, math) {
            const limit = currentLimit;
            const resolution = 60;
            
            // Создаем сетку для heatmap
            const x = [], y = [], z = [];
            const step = (2 * limit) / resolution;
            
            for (let j = 0; j <= resolution; j++) {
                const yj = -limit + j * step;
                y.push(yj);
                const row = [];
                for (let i = 0; i <= resolution; i++) {
                    const xi = -limit + i * step;
                    if (j === 0) x.push(xi);
                    const u = a * xi + b * yj;
                    const v = c * xi + d * yj;
                    row.push(Math.sqrt(u * u + v * v));
                }
                z.push(row);
            }
            
            // Нормализуем скорость
            const maxSpeed = Math.max(...z.flat()) || 1;
            const normalizedZ = z.map(row => row.map(val => Math.min(val / maxSpeed, 1.0)));
            
            // Heatmap (поле скоростей)
            const heatmap = {
                x, y, z: normalizedZ,
                type: 'heatmap',
                colorscale: [
                    [0, '#18181c'],
                    [0.3, '#1e2a3a'],
                    [0.6, '#2a3f5f'],
                    [0.8, '#3d5a80'],
                    [1, '#4f8cff']
                ],
                showscale: false,
                opacity: 0.4,
                hoverinfo: 'skip',
                name: 'Поле скоростей (яркость = скорость)',
                showlegend: true
            };
            
            // Траектории со стрелками
            const streamlines = createStreamlinesWithArrows(a, b, c, d, limit, math);
            
            // Особая точка
            const equilibrium = {
                x: [0], y: [0],
                type: 'scatter',
                mode: 'markers',
                marker: { 
                    color: '#ff5f5f', 
                    size: 10, 
                    line: { color: '#18181c', width: 2 },
                    symbol: 'circle'
                },
                hoverinfo: 'skip',
                name: 'Особая точка',
                showlegend: true
            };
            
            return [heatmap, ...streamlines, equilibrium];
        }
        
        function createStreamlinesWithArrows(a, b, c, d, limit, math) {
            const density = currentDensity;
            const streamlines = [];
            const seeds = [];
            
            // Генерируем начальные точки
            const numCircles = Math.floor(3 * density);
            for (let r = 0.4; r <= limit * 0.7; r += limit / (numCircles + 2)) {
                const numPoints = Math.floor(8 * density);
                for (let i = 0; i < numPoints; i++) {
                    const angle = (2 * Math.PI * i) / numPoints + (r * 0.1);
                    seeds.push({ x: r * Math.cos(angle), y: r * Math.sin(angle) });
                }
            }
            
            // Интегрируем траектории
            let isFirstTraj = true;
            let isFirstArrow = true;
            seeds.forEach(seed => {
                const traj = integrateTrajectory(a, b, c, d, seed.x, seed.y, limit);
                if (traj.x.length > 3) {
                    // Линия траектории
                    streamlines.push({
                        x: traj.x,
                        y: traj.y,
                        type: 'scatter',
                        mode: 'lines',
                        line: { color: '#4ade80', width: 1.3 },
                        opacity: 0.7,
                        hoverinfo: 'skip',
                        name: isFirstTraj ? 'Фазовые траектории' : '',
                        showlegend: isFirstTraj,
                        legendgroup: 'trajectories'
                    });
                    isFirstTraj = false;
                    
                    // Стрелки направления
                    const arrowSize = limit * 0.018;
                    const numArrows = Math.min(2, Math.floor(traj.x.length / 25));
                    
                    for (let i = 0; i < numArrows; i++) {
                        const idx = Math.floor((i + 1) * traj.x.length / (numArrows + 1));
                        if (idx > 0 && idx < traj.x.length - 1) {
                            const dx = traj.x[idx + 1] - traj.x[idx - 1];
                            const dy = traj.y[idx + 1] - traj.y[idx - 1];
                            const len = Math.sqrt(dx * dx + dy * dy);
                            if (len > 0.01) {
                                const arrow = createArrowhead(
                                    traj.x[idx], traj.y[idx],
                                    dx / len, dy / len,
                                    arrowSize
                                );
                                if (isFirstArrow) {
                                    arrow.name = 'Направление движения';
                                    arrow.showlegend = true;
                                    arrow.legendgroup = 'arrows';
                                    isFirstArrow = false;
                                }
                                streamlines.push(arrow);
                            }
                        }
                    }
                }
            });
            
            return streamlines;
        }
        
        function createArrowhead(x, y, dx, dy, size) {
            const angle = Math.atan2(dy, dx);
            const angle1 = angle + 2.6;
            const angle2 = angle - 2.6;
            
            return {
                x: [x - size * Math.cos(angle1), x, x - size * Math.cos(angle2)],
                y: [y - size * Math.sin(angle1), y, y - size * Math.sin(angle2)],
                type: 'scatter',
                mode: 'lines',
                line: { color: '#4ade80', width: 1.3 },
                hoverinfo: 'skip',
                showlegend: false
            };
        }
        
        function integrateTrajectory(a, b, c, d, x0, y0, limit) {
            const dt = 0.04;
            const maxSteps = 150;
            const x = [x0], y = [y0];
            let x_curr = x0, y_curr = y0;
            
            // Вперед
            for (let i = 0; i < maxSteps; i++) {
                const dx = a * x_curr + b * y_curr;
                const dy = c * x_curr + d * y_curr;
                const speed = Math.sqrt(dx * dx + dy * dy);
                if (speed < 1e-5) break;
                
                const adaptDt = Math.min(dt, 0.15 / (speed + 0.1));
                x_curr += dx * adaptDt;
                y_curr += dy * adaptDt;
                
                if (Math.abs(x_curr) > limit * 1.1 || Math.abs(y_curr) > limit * 1.1) break;
                x.push(x_curr);
                y.push(y_curr);
            }
            
            // Назад
            x_curr = x0; y_curr = y0;
            const x_back = [], y_back = [];
            
            for (let i = 0; i < maxSteps; i++) {
                const dx = a * x_curr + b * y_curr;
                const dy = c * x_curr + d * y_curr;
                const speed = Math.sqrt(dx * dx + dy * dy);
                if (speed < 1e-5) break;
                
                const adaptDt = Math.min(dt, 0.15 / (speed + 0.1));
                x_curr -= dx * adaptDt;
                y_curr -= dy * adaptDt;
                
                if (Math.abs(x_curr) > limit * 1.1 || Math.abs(y_curr) > limit * 1.1) break;
                x_back.unshift(x_curr);
                y_back.unshift(y_curr);
            }
            
            return { x: [...x_back, ...x], y: [...y_back, ...y] };
        }
        
        function updateMathInfo(math) {
            document.getElementById('mathTr').textContent = math.tr.toFixed(3);
            document.getElementById('mathDet').textContent = math.det.toFixed(3);
            
            if (math.isComplex) {
                const sign = math.lambda1.imag >= 0 ? '+' : '';
                document.getElementById('mathLambda1').textContent = 
                    `${math.lambda1.real.toFixed(2)} ${sign} ${math.lambda1.imag.toFixed(2)}i`;
                document.getElementById('mathLambda2').textContent = 
                    `${math.lambda2.real.toFixed(2)} ${sign} ${math.lambda2.imag.toFixed(2)}i`;
            } else {
                document.getElementById('mathLambda1').textContent = math.lambda1.toFixed(3);
                document.getElementById('mathLambda2').textContent = math.lambda2.toFixed(3);
            }
            
            document.getElementById('mathType').textContent = math.pointType;
        }
        
        // Обновление при изменении размера окна
        window.addEventListener('resize', () => requestUpdate());
    </script>
</body>
</html>
